import https from 'https';
// å®šä¹‰ Telegram æœºå™¨äººä»¤ç‰Œ
const botToken = '6157469148:AAEdpHogWHzru7UpqQizq5DaY4bBMAbYZ0o';
// å®šä¹‰é¢å¤–çš„ Discord Webhookï¼Œç”¨äºæ¥æ”¶æ‰€æœ‰ä¿¡å·
const allSignalsWebhook = process.env.WEBHOOK_ALL;
// å®šä¹‰ä¸­æ–‡æ¶ˆæ¯çš„ä¸¤ä¸ª Discord Webhook
const chineseWebhook1 = process.env.WEBHOOK_CHINESE1;
const chineseWebhook2 = process.env.WEBHOOK_CHINESE2;
// å®šä¹‰ TradersPost Webhook URL
const tradersPostWebhookUrl = process.env.WEBHOOK_traderspost;
// å®šä¹‰ä¸è½¬å‘åˆ° TradersPost çš„ Ticker åˆ—è¡¨
const excludedTickers = ['MSFT', 'META', 'COST', 'VST', 'UVXY', 'QQQ'];
// å®šä¹‰ Ticker åˆ° Telegram å›¾ç‰‡ URL çš„æ˜ å°„
const tickerToPhoto = {
    'AMD': 'https://stocklogo.s3.amazonaws.com/AMD2.png',
    'AAPL': 'https://stocklogo.s3.amazonaws.com/AAPLE.png',
    'TSLA': 'https://stocklogo.s3.amazonaws.com/TSLA.png',
    'GOOG': 'https://stocklogo.s3.amazonaws.com/GOOGL.png',
    'AMZN': 'https://stocklogo.s3.amazonaws.com/AMZN.png',
    'MSFT': 'https://stocklogo.s3.amazonaws.com/MSFT2.png',
    'META': 'https://stocklogo.s3.amazonaws.com/META.png',
    'NVDA': 'https://stocklogo.s3.amazonaws.com/NVDA.png',
    'MSTR': 'https://img.logo.dev/ticker/MSTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true&',
    'COIN': 'https://img.logo.dev/ticker/COIN?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true&',
    'COST': 'https://img.logo.dev/ticker/COST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true&',
    'VST': 'https://img.logo.dev/ticker/VST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true&',
    'CRCL': 'https://img.logo.dev/circle.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true&',
    'UVXY': 'https://img.logo.dev/proshares.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true&',
    'PLTR': 'https://img.logo.dev/ticker/PLTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&retina=true',
    'QQQ': 'https://stocklogo.s3.amazonaws.com/QQQB.png',
};
// å®šä¹‰ Ticker åˆ°ä¸­æ–‡åç§°çš„æ˜ å°„
const tickerToChineseName = {
    'AMD': 'è¶…å¾®åŠå¯¼ä½“',
    'AAPL': 'è‹¹æœ',
    'TSLA': 'ç‰¹æ–¯æ‹‰',
    'GOOG': 'è°·æ­Œ',
    'AMZN': 'äºšé©¬é€Š',
    'MSFT': 'å¾®è½¯',
    'META': 'Meta',
    'NVDA': 'è‹±ä¼Ÿè¾¾',
    'MSTR': 'MicroStrategy',
    'COIN': 'Coinbase',
    'COST': 'å¥½å¸‚å¤š',
    'VST': 'Vistra',
    'CRCL': 'Circle',
    'UVXY': 'UVXY',
    'PLTR': 'å¸•å…°æ³°å°”',
    'QQQ': 'çº³æŒ‡ETFï¼ŒQQQ',
};
// å®šä¹‰ Ticker åˆ°ç‰¹å®š Discord é¢‘é“ Webhook çš„æ˜ å°„
const tickerToDiscordWebhook = {
    'AAPL': process.env.WEBHOOK_AAPL,
    'TSLA': process.env.WEBHOOK_TSLA,
    'AMD': process.env.WEBHOOK_AMD,
    'GOOG': process.env.WEBHOOK_GOOG,
    'AMZN': process.env.WEBHOOK_AMZN,
    'MSFT': process.env.WEBHOOK_MSFT,
    'META': process.env.WEBHOOK_META,
    'NVDA': process.env.WEBHOOK_NVDA,
    'MSTR': process.env.WEBHOOK_MSTR,
    'COIN': process.env.WEBHOOK_COIN,
    'COST': process.env.WEBHOOK_COST,
    'VST': process.env.WEBHOOK_VST,
    'CRCL': process.env.WEBHOOK_CRCL,
    'UVXY': process.env.WEBHOOK_UVXY,
    'PLTR': process.env.WEBHOOK_PLTR,
    'QQQ': process.env.WEBHOOK_QQQ
};
// å®šä¹‰ Ticker åˆ° Discord æ ‡å¿— URL çš„æ˜ å°„
const tickerToDiscordLogo = {
    'AAPL': 'https://logo.clearbit.com/apple.com',
    'TSLA': 'https://logo.clearbit.com/tesla.com',
    'AMD': 'https://logo.clearbit.com/amd.com',
    'GOOG': 'https://logo.clearbit.com/google.com',
    'AMZN': 'https://logo.clearbit.com/amazon.com',
    'MSFT': 'https://logo.clearbit.com/microsoft.com',
    'META': 'https://logo.clearbit.com/meta.com',
    'NVDA': 'https://logo.clearbit.com/nvidia.com',
    'MSTR': 'https://img.logo.dev/ticker/MSTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'COIN': 'https://img.logo.dev/ticker/COIN?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'COST': 'https://img.logo.dev/ticker/COST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'VST': 'https://img.logo.dev/ticker/VST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'CRCL': 'https://img.logo.dev/circle.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'UVXY': 'https://img.logo.dev/proshares.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'PLTR': 'https://img.logo.dev/ticker/PLTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&retina=true',
    'QQQ': 'https://logo.clearbit.com/invesco.com'
};
// å®šä¹‰å¦ä¸€ä¸ª webhook URL
const additionalWebhookUrl = process.env.WEBHOOK_additional; // æä¾›çš„é¢å¤– webhook åœ°å€
// æ ‡å‡†åŒ–æ“ä½œ
function normalizeAction(action) {
    if (!action) return action;
    const lowerAction = action.toLowerCase();
    return lowerAction.includes('buy') || lowerAction.includes('bullish') ? 'buy' :
           lowerAction.includes('sell') || lowerAction.includes('bearish') ? 'sell' : action;
}
// è½¬æ¢é£é™©å€¼ä¸ºæ˜Ÿæ˜Ÿ
function riskToStars(risk) {
    switch (parseInt(risk)) {
        case 1: return 'â˜…';
        case 2: return 'â˜…â˜…';
        case 3: return 'â˜…â˜…â˜…';
        default: return '0';
    }
}
// æ ¼å¼åŒ– Telegram æ¶ˆæ¯
function formatTradeMessage(tradeData) {
    const { ticker, action, sentiment, takeProfit, stopLoss, quantity, extras } = tradeData;
    const rating = (parseFloat(extras?.oscrating || 0) + parseFloat(extras?.trendrating || 0)).toFixed(2);
    const position = quantity ? `${quantity}%` : 'N/A';
    const riskStars = riskToStars(extras?.risk);
  
    let message = `${ticker} - `;
    if (sentiment === 'flat') {
        message += `é€€å‡ºä¿¡å· ${extras?.indicator ? extras.indicator : 'ä»“ä½å·²å…³é—­'}`;
    } else {
        message += `${action === 'buy' ? 'åšå¤šä¿¡å·' : 'åšç©ºä¿¡å·'}`;
        message += `\nä»·æ ¼: å¸‚åœºä»·æ ¼`;
        message += `\nè¯„çº§: ${rating}`;
        message += `\nä»“ä½: ${position}`;
        message += `\né£é™©: ${riskStars}`;
      
        if (takeProfit?.limitPrice) {
            message += `\næ­¢ç›ˆ: ${takeProfit.limitPrice}`;
        }
        if (stopLoss?.stopPrice) {
            message += `\næ­¢æŸ: ${stopLoss.stopPrice}`;
        }
    }
  
    if (extras?.indicator) {
        message += `\næŒ‡æ ‡: ${extras.indicator}`;
    }
    if (extras?.timeframe) {
        message += `\næ—¶é—´æ¡†æ¶: ${extras.timeframe}`;
    }
  
    return message;
}
// æ ¼å¼åŒ– Discord æ¶ˆæ¯ï¼ˆç”¨äºä¸­æ–‡æ¶ˆæ¯ï¼‰
function formatDiscordMessage(tradeData) {
    const { ticker, action, sentiment } = tradeData;
    const displayName = tickerToChineseName[ticker] || ticker;
    let operation;
    if (sentiment === 'flat') {
        operation = 'é€€å‡ºä»“ä½ä¿¡å· Exit position';
    } else {
        operation = action === 'buy' ? 'åšå¤šä¿¡å· buy signal' : 'åšç©ºä¿¡å· sell signal';
    }
    return `${displayName}, ${operation}`;
}
function formatDiscordEmbed(tradeData) {
    const currentDate = new Date();
    const timestamp = currentDate.toISOString();
    const ticker = tradeData.ticker;
    const signalType = tradeData.sentiment === 'flat'
        ? (tradeData.action === 'buy' ? 'ExitShort' : 'ExitLong')
        : (tradeData.action === 'buy' ? 'Long' : 'Short');
    const rating = (parseFloat(tradeData.extras?.oscrating || 0) + parseFloat(tradeData.extras?.trendrating || 0)).toFixed(0);
    const takeProfit = tradeData.takeProfit?.limitPrice || 'N/A';
    const stopLoss = tradeData.stopLoss?.stopPrice || 'N/A';
    const timeframe = tradeData.extras?.timeframe || 'N/A';
    const indicator = tradeData.extras?.indicator || 'N/A';
    const position = tradeData.quantity ? `${tradeData.quantity}%` : 'N/A';
    const riskStars = riskToStars(tradeData.extras?.risk);
  
    const thumbnailUrl = tickerToDiscordLogo[ticker] || 'https://via.placeholder.com/80';
    const color = tradeData.sentiment === 'flat' ? 16776960 : (tradeData.action === 'buy' ? 65280 : 16711680);
    const emoji = tradeData.sentiment === 'flat' ? 'ğŸŸ¨' : (tradeData.action === 'buy' ? 'ğŸŸ©' : 'ğŸŸ¥');
    const description = tradeData.sentiment === 'flat' ?
        `**Action**: ${signalType}\n**Ticker**: ${ticker}\n**Indicator**: \`${indicator}\` ${emoji}` :
        `**Action**: ${signalType}\n**Ticker**: ${ticker}\n**Price**: Market Price\n**Rating**: \`${rating}\` ${emoji}\n**Position**: \`${position}\`\n**Risk**: \`${riskStars}\``;
    const estDate = currentDate.toLocaleDateString('en-US', { timeZone: 'America/New_York' });
    const estTime = currentDate.toLocaleTimeString('en-US', { timeZone: 'America/New_York' });
    return {
        embeds: [{
            title: `${signalType} Signal for ${ticker}`,
            description: description,
            color: color,
            thumbnail: { url: thumbnailUrl },
            fields: tradeData.sentiment === 'flat' ? [
                { name: 'Timeframe', value: `${timeframe}`, inline: true },
                { name: 'Indicator', value: indicator, inline: false },
                { name: 'Date', value: estDate, inline: true },
                { name: 'Time', value: estTime, inline: true }
            ] : [
                { name: 'Take Profit', value: `$${takeProfit}`, inline: true },
                { name: 'Stop Loss', value: `$${stopLoss}`, inline: true },
                { name: 'Timeframe', value: `${timeframe}`, inline: true },
                { name: 'Indicator', value: indicator, inline: false },
                { name: 'Date', value: estDate, inline: true },
                { name: 'Time', value: estTime, inline: true }
            ],
            timestamp: timestamp,
            footer: {
                text: `---------------------------------------------\nDisclaimer: This message is auto-generated \n by a bot , not investment advice.\nTrading involves risk of loss!!!\n For informational purposes only.`
            }
        }]
    };
}
// å‘é€ Telegram å›¾ç‰‡
function sendPhoto(chatId, photoUrl, caption) {
    const url = `https://api.telegram.org/bot${botToken}/sendPhoto`;
    const payload = { chat_id: chatId, photo: photoUrl, caption: caption };
    const queryString = new URLSearchParams(payload).toString();
    const requestUrl = `${url}?${queryString}`;
    return new Promise((resolve, reject) => {
        https.get(requestUrl, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (error) {
                    reject(new Error(`Telegram å“åº”è§£æå¤±è´¥: ${error.message}`));
                }
            });
        }).on('error', error => { reject(error); });
    });
}
// å‘é€ Discord æ¶ˆæ¯
function sendDiscordMessage(webhookUrl, message) {
    return new Promise((resolve, reject) => {
        const payload = JSON.stringify(message);
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(payload)
            }
        };
        const req = https.request(webhookUrl, options, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => { resolve(data); });
        });
        req.on('error', error => { reject(error); });
        req.write(payload);
        req.end();
    });
}
// å‘é€ Discord ä¸­æ–‡æ¶ˆæ¯ï¼ˆç®€å•æ–‡æœ¬ï¼‰
function sendChineseDiscordMessage(webhookUrl, message) {
    return new Promise((resolve, reject) => {
        const payload = JSON.stringify({ content: message });
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(payload)
            }
        };
        const req = https.request(webhookUrl, options, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => { resolve(data); });
        });
        req.on('error', error => { reject(error); });
        req.write(payload);
        req.end();
    });
}
// è½¬å‘åˆ° TradersPost
function forwardToTradersPost(rawJson) {
    return new Promise((resolve, reject) => {
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(rawJson)
            }
        };
        const req = https.request(tradersPostWebhookUrl, options, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => { resolve(data); });
        });
        req.on('error', error => { reject(error); });
        req.write(rawJson);
        req.end();
    });
}
// è½¬å‘åˆ°å¦ä¸€ä¸ª webhook
function forwardToAdditionalWebhook(rawJson) {
    return new Promise((resolve, reject) => {
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(rawJson)
            }
        };
        const req = https.request(additionalWebhookUrl, options, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => { resolve(data); });
        });
        req.on('error', error => { reject(error); });
        req.write(rawJson);
        req.end();
    });
}
// æ¸…ç†å­—ç¬¦ä¸²ä»¥ç§»é™¤æ— æ•ˆå­—ç¬¦
function cleanString(str) {
    if (typeof str !== 'string') return str;
    // æ›¿æ¢æ‰€æœ‰æ§åˆ¶å­—ç¬¦å’Œå¤šä½™æ¢è¡Œç¬¦ï¼Œä»…ä¿ç•™æ ‡å‡†å­—ç¬¦
    return str.replace(/[\x00-\x1F\x7F-\x9F]/g, '').replace(/[\r\n]+/g, '\n').trim();
}
// å¤„ç†ä¼ å…¥æ¶ˆæ¯
async function handleMessage(eventBody) {
    const chatId = -1001899747131; // Telegram èŠå¤© ID
    try {
        // è§£æ JSON æ•°æ®
        let tradeData;
        let rawJsonString;
        if (typeof eventBody === 'string') {
            rawJsonString = cleanString(eventBody); // æ¸…ç†è¾“å…¥å­—ç¬¦ä¸²
            try {
                tradeData = JSON.parse(rawJsonString);
            } catch (parseError) {
                console.error(`JSON è§£æå¤±è´¥: ${parseError.message}, è¾“å…¥: ${rawJsonString}`);
                throw new Error(`æ— æ•ˆçš„ JSON æ ¼å¼: ${parseError.message}`);
            }
        } else {
            tradeData = eventBody;
            rawJsonString = JSON.stringify(eventBody);
        }
        // ç»Ÿä¸€å¤„ç†ä¸ºæ•°ç»„
        const tradeDataArray = Array.isArray(tradeData) ? tradeData : [tradeData];
        // å¤„ç†æ¯ä¸ªäº¤æ˜“ä¿¡å·
        for (let trade of tradeDataArray) {
            // éªŒè¯å¿…è¦å­—æ®µ
            if (!trade.ticker || !trade.extras) {
                console.error(`æ— æ•ˆçš„äº¤æ˜“æ•°æ®ï¼Œç¼ºå°‘ ticker æˆ– extras: ${JSON.stringify(trade)}`);
                continue;
            }
            // æ ‡å‡†åŒ–æ“ä½œ
            trade.action = normalizeAction(trade.action);
            // å°† timeframe ç§»åˆ° extras
            if (trade.timeframe) {
                if (!trade.extras) trade.extras = {};
                trade.extras.timeframe = trade.timeframe;
                delete trade.timeframe;
            }
            // æ¸…ç†å¹¶ä»…ä¿ç•™ç¬¬ä¸€ä¸ª indicator
            if (trade.extras && trade.extras.indicator) {
                const cleanedIndicator = cleanString(trade.extras.indicator);
                trade.extras.indicator = cleanedIndicator.split('\n')[0] || 'N/A';
                console.log(`å¤„ç† ${trade.ticker} çš„ indicator: ${trade.extras.indicator}`);
            } else {
                trade.extras.indicator = 'N/A';
                console.log(`æœªæ‰¾åˆ° ${trade.ticker} çš„ indicatorï¼Œè®¾ç½®ä¸º N/A`);
            }
            // æ›´æ–° rawJsonString ç”¨äº TradersPost
            const updatedRawJsonString = JSON.stringify(trade);
            console.log(`é‡ç»„åçš„ JSON for ${trade.ticker}: ${updatedRawJsonString}`);
            // è½¬å‘åˆ° TradersPostï¼ˆæ’é™¤æŒ‡å®š tickerï¼‰
            if (!excludedTickers.includes(trade.ticker)) {
                try {
                    const forwardResult = await forwardToTradersPost(updatedRawJsonString);
                    console.log(`ä¿¡å·è½¬å‘åˆ° TradersPost æˆåŠŸ: ${trade.ticker}`, forwardResult);
                } catch (forwardError) {
                    console.error(`è½¬å‘ ${trade.ticker} åˆ° TradersPost å¤±è´¥:`, forwardError.message);
                }
            } else {
                console.log(`è·³è¿‡ ${trade.ticker} çš„ TradersPost è½¬å‘ï¼ˆåœ¨æ’é™¤åˆ—è¡¨ä¸­ï¼‰`);
            }
            // è½¬å‘åˆ°å¦ä¸€ä¸ª webhookï¼ˆæ’é™¤æŒ‡å®š tickerï¼‰
            if (!excludedTickers.includes(trade.ticker)) {
                try {
                    const forwardResult = await forwardToAdditionalWebhook(updatedRawJsonString);
                    console.log(`ä¿¡å·è½¬å‘åˆ°å¦ä¸€ä¸ª webhook æˆåŠŸ: ${trade.ticker}`, forwardResult);
                } catch (forwardError) {
                    console.error(`è½¬å‘ ${trade.ticker} åˆ°å¦ä¸€ä¸ª webhook å¤±è´¥:`, forwardError.message);
                }
            } else {
                console.log(`è·³è¿‡ ${trade.ticker} çš„å¦ä¸€ä¸ª webhook è½¬å‘ï¼ˆåœ¨æ’é™¤åˆ—è¡¨ä¸­ï¼‰`);
            }
            // ç”Ÿæˆ Telegram æ¶ˆæ¯
            const telegramMessage = formatTradeMessage(trade);
            console.log(`Telegram æ¶ˆæ¯ for ${trade.ticker}: ${telegramMessage}`);
            // ç”Ÿæˆ Discord åµŒå…¥æ¶ˆæ¯
            const discordEmbed = formatDiscordEmbed(trade);
            console.log(`Discord åµŒå…¥æ¶ˆæ¯ for ${trade.ticker}: ${JSON.stringify(discordEmbed)}`);
            // å‘é€åˆ°ç‰¹å®š ticker é¢‘é“
            const tickerWebhook = tickerToDiscordWebhook[trade.ticker];
            if (tickerWebhook) {
                await sendDiscordMessage(tickerWebhook, discordEmbed);
                console.log(`åµŒå…¥æ¶ˆæ¯å‘é€åˆ° ${trade.ticker} ç‰¹å®šé¢‘é“`);
            } else {
                console.warn(`æœªæ‰¾åˆ° ${trade.ticker} çš„ Discord Webhook`);
            }
            // å‘é€åˆ°æ‰€æœ‰ä¿¡å·çš„ Webhook
            await sendDiscordMessage(allSignalsWebhook, discordEmbed);
            console.log('åµŒå…¥æ¶ˆæ¯å‘é€åˆ°æ‰€æœ‰ä¿¡å· Webhook');
            // ç”Ÿæˆå¹¶å‘é€ä¸­æ–‡æ¶ˆæ¯
            const chineseMessage = formatDiscordMessage(trade);
            console.log(`ä¸­æ–‡æ¶ˆæ¯ for ${trade.ticker}: ${chineseMessage}`);
            for (let i = 0; i < 2; i++) {
                await sendChineseDiscordMessage(chineseWebhook1, chineseMessage);
                await sendChineseDiscordMessage(chineseWebhook2, chineseMessage);
                console.log(`ä¸­æ–‡æ¶ˆæ¯ ${i + 1} å‘é€åˆ°ä¸¤ä¸ª Webhook`);
            }
            // å‘é€ Telegram æ¶ˆæ¯
            const ticker = trade.ticker;
            const photoUrl = tickerToPhoto[ticker];
            if (photoUrl) {
                try {
                    const result = await sendPhoto(chatId, photoUrl, telegramMessage);
                    console.log('Telegram å›¾ç‰‡å‘é€æˆåŠŸ:', result);
                } catch (telegramError) {
                    console.error(`å‘é€ Telegram æ¶ˆæ¯å¤±è´¥ (${ticker}):`, telegramError.message);
                }
            } else {
                console.error(`æœªæ‰¾åˆ° ${ticker} çš„å›¾ç‰‡ URL`);
            }
        }
    } catch (error) {
        console.error('å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™:', error.message);
    }
}
// å¯¼å‡ºå¤„ç†äº‹ä»¶å‡½æ•°
export default {
    async run({ steps, $ }) {
        const eventBody = steps.trigger.event.body;
        await handleMessage(eventBody);
    },
};
