import https from 'https';

// å®šä¹‰ Telegram æœºå™¨äººä»¤ç‰Œ
const botToken = '6157469148:AAEdpHogWHzru7UpqQizq5DaY4bBMAbYZ0o';

// å®šä¹‰é¢å¤–çš„ Discord Webhookï¼Œç”¨äºæ¥æ”¶æ‰€æœ‰ä¿¡å·
const allSignalsWebhook = 'https://discord.com/api/webhooks/1370397296810000404/609fjo7DqG1KeSxCbt_ckU532CYyswISxTJoHwbrjLjyxqT0DbZ1us62rLq8JMgFMA4U';

// å®šä¹‰ä¸­æ–‡æ¶ˆæ¯çš„ä¸¤ä¸ª Discord Webhook
const chineseWebhook1 = 'https://discordapp.com/api/webhooks/1370414675648446524/Nc2XBdFRRIjGkuMNP51XevlAaaNeIAJq1f6XH-UTSbvUGijXW9eC4RdS7kdVKmEDDiot';
const chineseWebhook2 = 'https://discordapp.com/api/webhooks/1388996914506104882/oGIDtxm2S4JOalHiNwdQnkcd9hVkijpeajXBdKfRgJO0wUILARbyVCwHZpIWaPMhf9Mm';

// å®šä¹‰ TradersPost Webhook URL
const tradersPostWebhookUrl = 'https://webhooks.traderspost.io/trading/webhook/80f88ec5-aadb-4d78-969f-947ca5f170da/97d9c4310fd49e11af320b03c2af2ff4';

// å®šä¹‰ä¸è½¬å‘åˆ° TradersPost çš„ Ticker åˆ—è¡¨
const excludedTickers = ['MSFT', 'META', 'COST', 'VST', 'UVXY', 'QQQ'];

// å®šä¹‰ Ticker åˆ° Telegram å›¾ç‰‡ URL çš„æ˜ å°„
const tickerToPhoto = {
    'AMD': 'https://stocklogo.s3.amazonaws.com/AMD2.png',
    'AAPL': 'https://stocklogo.s3.amazonaws.com/AAPLE.png',
    'TSLA': 'https://stocklogo.s3.amazonaws.com/TSLA.png',
    'GOOG': 'https://stocklogo.s3.amazonaws.com/GOOGL.png',
    'AMZN': 'https://stocklogo.s3.amazonaws.com/AMZN.png',
    'MSFT': 'https://stocklogo.s3.amazonaws.com/MSFT2.png',
    'META': 'https://stocklogo.s3.amazonaws.com/META.png',
    'NVDA': 'https://stocklogo.s3.amazonaws.com/NVDA.png',
    'MSTR': 'https://img.logo.dev/ticker/MSTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'COIN': 'https://img.logo.dev/ticker/COIN?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'COST': 'https://img.logo.dev/ticker/COST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'VST': 'https://img.logo.dev/ticker/VST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'CRCL': 'https://img.logo.dev/circle.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'UVXY': 'https://img.logo.dev/proshares.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'PLTR': 'https://img.logo.dev/ticker/PLTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&retina=true',
    'QQQ': 'https://stocklogo.s3.amazonaws.com/QQQB.png',
};

// å®šä¹‰ Ticker åˆ°ä¸­æ–‡åç§°çš„æ˜ å°„
const tickerToChineseName = {
    'AMD': 'è¶…å¾®åŠå¯¼ä½“',
    'AAPL': 'è‹¹æœ',
    'TSLA': 'ç‰¹æ–¯æ‹‰',
    'GOOG': 'è°·æ­Œ',
    'AMZN': 'äºšé©¬é€Š',
    'MSFT': 'å¾®è½¯',
    'META': 'Meta',
    'NVDA': 'è‹±ä¼Ÿè¾¾',
    'MSTR': 'MicroStrategy',
    'COIN': 'Coinbase',
    'COST': 'å¥½å¸‚å¤š',
    'VST': 'Vistra',
    'CRCL': 'Circle',
    'UVXY': 'UVXY',
    'PLTR': 'å¸•å…°æ³°å°”',
    'QQQ': 'çº³æŒ‡ETFï¼ŒQQQ',
};

// å®šä¹‰ Ticker åˆ°ç‰¹å®š Discord é¢‘é“ Webhook çš„æ˜ å°„
const tickerToDiscordWebhook = {
    'AAPL': 'https://discordapp.com/api/webhooks/1384984109402689536/KWmGl6YzU8jj6WdNTzc8Jz0PoLlhAXQwWliJAU5xe1dQ68n6La0OsAlPwngibf1YQM_9',
    'TSLA': 'https://discordapp.com/api/webhooks/1384971572195889402/zr3jdJrA1fI5NG-cTaZlcXXRZ8Z2CnFbFeUU8Nh21aFCiZ5VKtbBE1hChZFhuizQx4B2',
    'AMD': 'https://discordapp.com/api/webhooks/1384988331506405506/V-1qDWLH-1QAM7PkiZdE_vses9VFwNiCsadkDIPxKT1kklkbRu5g-1MCoRpm93npyMtO',
    'GOOG': 'https://discordapp.com/api/webhooks/1384983064521998386/kW8zVCY_pL4qiOClCfDlx6ChtZGDghnUp-agxALY7xOuvFUddkkSOJcj_hD_381xkcoW',
    'AMZN': 'https://discordapp.com/api/webhooks/1384977707682627724/EGBG92iv8cza1V3fXOXNf_pb7X8qKtM6hBQQaiA4IgPisCNgTOCDEr0SzYL8vvTM-XDt',
    'MSFT': 'https://discordapp.com/api/webhooks/1384985492402995311/kX9DQn4nZLsVIfw9XrOZQz2R-L6cTB95hQbmZ2VlaSFg5tm8cIT5K4vOQzQz_RoDSyfT',
    'META': 'https://discordapp.com/api/webhooks/1384982325590491207/4T2e0Ib47snv1LLvuBsv1tu1KLAmsxkNFZi14hwUqnHKzdsBhu9KwcnfxHs3r3rcAAyR',
    'NVDA': 'https://discordapp.com/api/webhooks/1384974875529318450/AmV0LRfisS5L-O9ddKFKW9WwFor2p5uGdeTU1jufjm7WlvxotHu18vbPyqgvwMjuGaWT',
    'MSTR': 'https://discordapp.com/api/webhooks/1384989174343532594/3mB0dHsYGjQ67kX6nahDY6Jq-1V6tHABdPkn9plut5T4-VATh5A9PSqdUwl80XOz0FnQ',
    'COIN': 'https://discordapp.com/api/webhooks/1384989467428782110/0irWk4-o2Vd6yD7O05XsL_n_vHHjd4NYjRZWYjgyoO-DF_GjuZnVZ-Repv8UF1Y0KCuy',
    'COST': 'https://discordapp.com/api/webhooks/1384990085786636328/pTFKLCvcSlhyjSKdy7biM8bmoADRfXA6EmR4xD1ZGWLR-U9zopw0G7QYyU8FVjP3LfPl',
    'VST': 'https://discordapp.com/api/webhooks/1384996016331165706/klDZ1qN-yq1e00eu9AVjxVRTg-rkzphCkf3ZrSYnhrXLQYcftOztRpK9YlDEF_CVjjPP',
    'CRCL': 'https://discordapp.com/api/webhooks/1386763467809230929/EDdBar1iTPwEp_sTSMaGAvJ1gOvbMjCtnguj2F0QUeTQWYmZVgdCvmPW1_M6tY4FeLrh',
    'UVXY': 'https://discordapp.com/api/webhooks/1386763979606720643/S5-pyun_Lo4S9UrJ07OYEeplnWnVIhy95RKMWlFYXR5oNtyKbTBlsZytPcUSfw1AU8xH',
    'PLTR': 'https://discordapp.com/api/webhooks/1398400349601271890/sy9xbOvElVm2cQFaRJQ4zawmEltagZD9UtQ2DiES6DD0QtO89rUUBiSXDJlWGSRJEJiH',
    'QQQ': 'https://discordapp.com/api/webhooks/1384986509706268895/seqCxPmOBrJpMFaVeqqEbpdGPxl5SbF8Dkmc_1FhkyW-_lZCbPQqfO8UeqS7OpGJeAbR'
};
// å®šä¹‰ Ticker åˆ° Discord æ ‡å¿— URL çš„æ˜ å°„
const tickerToDiscordLogo = {
    'AAPL': 'https://logo.clearbit.com/apple.com',
    'TSLA': 'https://logo.clearbit.com/tesla.com',
    'AMD': 'https://logo.clearbit.com/amd.com',
    'GOOG': 'https://logo.clearbit.com/google.com',
    'AMZN': 'https://logo.clearbit.com/amazon.com',
    'MSFT': 'https://logo.clearbit.com/microsoft.com',
    'META': 'https://logo.clearbit.com/meta.com',
    'NVDA': 'https://logo.clearbit.com/nvidia.com',
    'MSTR': 'https://img.logo.dev/ticker/MSTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'COIN': 'https://img.logo.dev/ticker/COIN?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'COST': 'https://img.logo.dev/ticker/COST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'VST': 'https://img.logo.dev/ticker/VST?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'CRCL': 'https://img.logo.dev/circle.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'UVXY': 'https://img.logo.dev/proshares.com?token=pk_ezLKIu-XSp2aKlPx2HnIBw&format=png&retina=true',
    'PLTR': 'https://img.logo.dev/ticker/PLTR?token=pk_ezLKIu-XSp2aKlPx2HnIBw&retina=true',
    'QQQ': 'https://logo.clearbit.com/invesco.com'
};

// æ ‡å‡†åŒ–æ“ä½œ
function normalizeAction(action) {
    if (!action) return action;
    const lowerAction = action.toLowerCase();
    return lowerAction.includes('buy') || lowerAction.includes('bullish') ? 'buy' : 
           lowerAction.includes('sell') || lowerAction.includes('bearish') ? 'sell' : action;
}

// è½¬æ¢é£é™©å€¼ä¸ºæ˜Ÿæ˜Ÿ
function riskToStars(risk) {
    switch (parseInt(risk)) {
        case 1: return 'â˜…';
        case 2: return 'â˜…â˜…';
        case 3: return 'â˜…â˜…â˜…';
        default: return '0';
    }
}

// æ ¼å¼åŒ– Telegram æ¶ˆæ¯
function formatTradeMessage(tradeData) {
    const { ticker, action, sentiment, takeProfit, stopLoss, quantity, extras } = tradeData;
    const rating = (parseFloat(extras?.oscrating || 0) + parseFloat(extras?.trendrating || 0)).toFixed(2);
    const position = quantity ? `${quantity}%` : 'N/A';
    const riskStars = riskToStars(extras?.risk);
    
    let message = `${ticker} - `;
    if (sentiment === 'flat') {
        message += `é€€å‡ºä¿¡å· ${extras?.indicator ? extras.indicator : 'ä»“ä½å·²å…³é—­'}`;
    } else {
        message += `${action === 'buy' ? 'åšå¤šä¿¡å·' : 'åšç©ºä¿¡å·'}`;
        message += `\nä»·æ ¼: å¸‚åœºä»·æ ¼`;
        message += `\nè¯„çº§: ${rating}`;
        message += `\nä»“ä½: ${position}`;
        message += `\né£é™©: ${riskStars}`;
        
        if (takeProfit?.limitPrice) {
            message += `\næ­¢ç›ˆ: ${takeProfit.limitPrice}`;
        }
        if (stopLoss?.stopPrice) {
            message += `\næ­¢æŸ: ${stopLoss.stopPrice}`;
        }
    }
    
    if (extras?.indicator) {
        message += `\næŒ‡æ ‡: ${extras.indicator}`;
    }
    if (extras?.timeframe) {
        message += `\næ—¶é—´æ¡†æ¶: ${extras.timeframe}`;
    }
    
    return message;
}

// æ ¼å¼åŒ– Discord æ¶ˆæ¯ï¼ˆç”¨äºä¸­æ–‡æ¶ˆæ¯ï¼‰
function formatDiscordMessage(tradeData) {
    const { ticker, action, sentiment } = tradeData;
    const displayName = tickerToChineseName[ticker] || ticker;
    let operation;
    if (sentiment === 'flat') {
        operation = 'é€€å‡ºä»“ä½ä¿¡å· Exit position';
    } else {
        operation = action === 'buy' ? 'åšå¤šä¿¡å· buy signal' : 'åšç©ºä¿¡å· sell signal';
    }
    return `${displayName}, ${operation}`;
}

function formatDiscordEmbed(tradeData) {
    const currentDate = new Date();
    const timestamp = currentDate.toISOString();
    const ticker = tradeData.ticker;
    const signalType = tradeData.sentiment === 'flat' 
        ? (tradeData.action === 'buy' ? 'ExitShort' : 'ExitLong')
        : (tradeData.action === 'buy' ? 'Long' : 'Short');
    const rating = (parseFloat(tradeData.extras?.oscrating || 0) + parseFloat(tradeData.extras?.trendrating || 0)).toFixed(0);
    const takeProfit = tradeData.takeProfit?.limitPrice || 'N/A';
    const stopLoss = tradeData.stopLoss?.stopPrice || 'N/A';
    const timeframe = tradeData.extras?.timeframe || 'N/A';
    const indicator = tradeData.extras?.indicator || 'N/A';
    const position = tradeData.quantity ? `${tradeData.quantity}%` : 'N/A';
    const riskStars = riskToStars(tradeData.extras?.risk);
    
    const thumbnailUrl = tickerToDiscordLogo[ticker] || 'https://via.placeholder.com/80';
    const color = tradeData.sentiment === 'flat' ? 16776960 : (tradeData.action === 'buy' ? 65280 : 16711680);

    const emoji = tradeData.sentiment === 'flat' ? 'ğŸŸ¨' : (tradeData.action === 'buy' ? 'ğŸŸ©' : 'ğŸŸ¥');
    const description = tradeData.sentiment === 'flat' ? 
        `**Action**: ${signalType}\n**Ticker**: ${ticker}\n**Indicator**: \`${indicator}\` ${emoji}` :
        `**Action**: ${signalType}\n**Ticker**: ${ticker}\n**Price**: Market Price\n**Rating**: \`${rating}\` ${emoji}\n**Position**: \`${position}\`\n**Risk**: \`${riskStars}\``;

    return {
        embeds: [{
            title: `${signalType} Signal for ${ticker}`,
            description: description,
            color: color,
            thumbnail: { url: thumbnailUrl },
            fields: tradeData.sentiment === 'flat' ? [
                { name: 'Timeframe', value: `${timeframe}`, inline: true },
                { name: 'Indicator', value: indicator, inline: true }
            ] : [
                { name: 'Take Profit', value: `$${takeProfit}`, inline: true },
                { name: 'Stop Loss', value: `$${stopLoss}`, inline: true },
                { name: 'Timeframe', value: `${timeframe}`, inline: true },
                { name: 'Indicator', value: indicator, inline: true }
            ],
            timestamp: timestamp,
            footer: {
                text: `---------------------------------------------\nDisclaimer: This message is auto-generated \n by a bot , not investment advice.\nTrading involves risk of loss!!!\n For informational purposes only.\nTime: ${currentDate.toLocaleString('en-US', { timeZone: 'America/New_York' })}`
            }
        }]
    };
}

// å‘é€ Telegram å›¾ç‰‡
function sendPhoto(chatId, photoUrl, caption) {
    const url = `https://api.telegram.org/bot${botToken}/sendPhoto`;
    const payload = { chat_id: chatId, photo: photoUrl, caption: caption };
    const queryString = new URLSearchParams(payload).toString();
    const requestUrl = `${url}?${queryString}`;

    return new Promise((resolve, reject) => {
        https.get(requestUrl, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (error) {
                    reject(new Error(`Telegram å“åº”è§£æå¤±è´¥: ${error.message}`));
                }
            });
        }).on('error', error => { reject(error); });
    });
}

// å‘é€ Discord æ¶ˆæ¯
function sendDiscordMessage(webhookUrl, message) {
    return new Promise((resolve, reject) => {
        const payload = JSON.stringify(message);
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(payload)
            }
        };

        const req = https.request(webhookUrl, options, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => { resolve(data); });
        });

        req.on('error', error => { reject(error); });
        req.write(payload);
        req.end();
    });
}

// å‘é€ Discord ä¸­æ–‡æ¶ˆæ¯ï¼ˆç®€å•æ–‡æœ¬ï¼‰
function sendChineseDiscordMessage(webhookUrl, message) {
    return new Promise((resolve, reject) => {
        const payload = JSON.stringify({ content: message });
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(payload)
            }
        };

        const req = https.request(webhookUrl, options, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => { resolve(data); });
        });

        req.on('error', error => { reject(error); });
        req.write(payload);
        req.end();
    });
}

// è½¬å‘åˆ° TradersPost
function forwardToTradersPost(rawJson) {
    return new Promise((resolve, reject) => {
        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(rawJson)
            }
        };

        const req = https.request(tradersPostWebhookUrl, options, response => {
            let data = '';
            response.on('data', chunk => { data += chunk; });
            response.on('end', () => { resolve(data); });
        });

        req.on('error', error => { reject(error); });
        req.write(rawJson);
        req.end();
    });
}

// æ¸…ç†å­—ç¬¦ä¸²ä»¥ç§»é™¤æ— æ•ˆå­—ç¬¦
function cleanString(str) {
    if (typeof str !== 'string') return str;
    // æ›¿æ¢æ‰€æœ‰æ§åˆ¶å­—ç¬¦å’Œå¤šä½™æ¢è¡Œç¬¦ï¼Œä»…ä¿ç•™æ ‡å‡†å­—ç¬¦
    return str.replace(/[\x00-\x1F\x7F-\x9F]/g, '').replace(/[\r\n]+/g, '\n').trim();
}

// å¤„ç†ä¼ å…¥æ¶ˆæ¯
async function handleMessage(eventBody) {
    const chatId = -1001899747131; // Telegram èŠå¤© ID

    try {
        // è§£æ JSON æ•°æ®
        let tradeData;
        let rawJsonString;
        if (typeof eventBody === 'string') {
            rawJsonString = cleanString(eventBody); // æ¸…ç†è¾“å…¥å­—ç¬¦ä¸²
            try {
                tradeData = JSON.parse(rawJsonString);
            } catch (parseError) {
                console.error(`JSON è§£æå¤±è´¥: ${parseError.message}, è¾“å…¥: ${rawJsonString}`);
                throw new Error(`æ— æ•ˆçš„ JSON æ ¼å¼: ${parseError.message}`);
            }
        } else {
            tradeData = eventBody;
            rawJsonString = JSON.stringify(eventBody);
        }

        // ç»Ÿä¸€å¤„ç†ä¸ºæ•°ç»„
        const tradeDataArray = Array.isArray(tradeData) ? tradeData : [tradeData];

        // å¤„ç†æ¯ä¸ªäº¤æ˜“ä¿¡å·
        for (let trade of tradeDataArray) {
            // éªŒè¯å¿…è¦å­—æ®µ
            if (!trade.ticker || !trade.extras) {
                console.error(`æ— æ•ˆçš„äº¤æ˜“æ•°æ®ï¼Œç¼ºå°‘ ticker æˆ– extras: ${JSON.stringify(trade)}`);
                continue;
            }

            // æ ‡å‡†åŒ–æ“ä½œ
            trade.action = normalizeAction(trade.action);

            // å°† timeframe ç§»åˆ° extras
            if (trade.timeframe) {
                if (!trade.extras) trade.extras = {};
                trade.extras.timeframe = trade.timeframe;
                delete trade.timeframe;
            }

            // æ¸…ç†å¹¶ä»…ä¿ç•™ç¬¬ä¸€ä¸ª indicator
            if (trade.extras && trade.extras.indicator) {
                const cleanedIndicator = cleanString(trade.extras.indicator);
                trade.extras.indicator = cleanedIndicator.split('\n')[0] || 'N/A';
                console.log(`å¤„ç† ${trade.ticker} çš„ indicator: ${trade.extras.indicator}`);
            } else {
                trade.extras.indicator = 'N/A';
                console.log(`æœªæ‰¾åˆ° ${trade.ticker} çš„ indicatorï¼Œè®¾ç½®ä¸º N/A`);
            }

            // æ›´æ–° rawJsonString ç”¨äº TradersPost
            const updatedRawJsonString = JSON.stringify(trade);
            console.log(`é‡ç»„åçš„ JSON for ${trade.ticker}: ${updatedRawJsonString}`);

            // è½¬å‘åˆ° TradersPostï¼ˆæ’é™¤æŒ‡å®š tickerï¼‰
            if (!excludedTickers.includes(trade.ticker)) {
                try {
                    const forwardResult = await forwardToTradersPost(updatedRawJsonString);
                    console.log(`ä¿¡å·è½¬å‘åˆ° TradersPost æˆåŠŸ: ${trade.ticker}`, forwardResult);
                } catch (forwardError) {
                    console.error(`è½¬å‘ ${trade.ticker} åˆ° TradersPost å¤±è´¥:`, forwardError.message);
                }
            } else {
                console.log(`è·³è¿‡ ${trade.ticker} çš„ TradersPost è½¬å‘ï¼ˆåœ¨æ’é™¤åˆ—è¡¨ä¸­ï¼‰`);
            }

            // ç”Ÿæˆ Telegram æ¶ˆæ¯
            const telegramMessage = formatTradeMessage(trade);
            console.log(`Telegram æ¶ˆæ¯ for ${trade.ticker}: ${telegramMessage}`);

            // ç”Ÿæˆ Discord åµŒå…¥æ¶ˆæ¯
            const discordEmbed = formatDiscordEmbed(trade);
            console.log(`Discord åµŒå…¥æ¶ˆæ¯ for ${trade.ticker}: ${JSON.stringify(discordEmbed)}`);

            // å‘é€åˆ°ç‰¹å®š ticker é¢‘é“
            const tickerWebhook = tickerToDiscordWebhook[trade.ticker];
            if (tickerWebhook) {
                await sendDiscordMessage(tickerWebhook, discordEmbed);
                console.log(`åµŒå…¥æ¶ˆæ¯å‘é€åˆ° ${trade.ticker} ç‰¹å®šé¢‘é“`);
            } else {
                console.warn(`æœªæ‰¾åˆ° ${trade.ticker} çš„ Discord Webhook`);
            }

            // å‘é€åˆ°æ‰€æœ‰ä¿¡å·çš„ Webhook
            await sendDiscordMessage(allSignalsWebhook, discordEmbed);
            console.log('åµŒå…¥æ¶ˆæ¯å‘é€åˆ°æ‰€æœ‰ä¿¡å· Webhook');

            // ç”Ÿæˆå¹¶å‘é€ä¸­æ–‡æ¶ˆæ¯
            const chineseMessage = formatDiscordMessage(trade);
            console.log(`ä¸­æ–‡æ¶ˆæ¯ for ${trade.ticker}: ${chineseMessage}`);
            for (let i = 0; i < 2; i++) {
                await sendChineseDiscordMessage(chineseWebhook1, chineseMessage);
                await sendChineseDiscordMessage(chineseWebhook2, chineseMessage);
                console.log(`ä¸­æ–‡æ¶ˆæ¯ ${i + 1} å‘é€åˆ°ä¸¤ä¸ª Webhook`);
            }

            // å‘é€ Telegram æ¶ˆæ¯
            const ticker = trade.ticker;
            const photoUrl = tickerToPhoto[ticker];
            if (photoUrl) {
                try {
                    const result = await sendPhoto(chatId, photoUrl, telegramMessage);
                    console.log('Telegram å›¾ç‰‡å‘é€æˆåŠŸ:', result);
                } catch (telegramError) {
                    console.error(`å‘é€ Telegram æ¶ˆæ¯å¤±è´¥ (${ticker}):`, telegramError.message);
                }
            } else {
                console.error(`æœªæ‰¾åˆ° ${ticker} çš„å›¾ç‰‡ URL`);
            }
        }
    } catch (error) {
        console.error('å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™:', error.message);
    }
}

// å¯¼å‡ºå¤„ç†äº‹ä»¶å‡½æ•°
export default {
    async run({ steps, $ }) {
        const eventBody = steps.trigger.event.body;
        await handleMessage(eventBody);
    },
};
